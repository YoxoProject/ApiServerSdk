/*
 * Yoxo API Server
 * API REST exposant diverses données liées aux serveurs de NationsGlory.  ## À propos Cette API centralise et expose différents types de données relatives aux serveurs de NationsGlory : - **Routes `/v2/java/_*`** : Données collectées par scraping direct sur les serveurs Java de NationsGlory. Pour cela, le protocole 78 (Minecraft 1.6.4) est pleinement utilisé. - **Autres routes** (à venir) : Données obtenues par d'autres méthodes (API officielles, DynMap, etc.)  ## Authentification L'API utilise le flux OAuth2 Client Credentials. Pour vous authentifier : 1. Obtenez vos identifiants client (client_id et client_secret) depuis le serveur d'authentification de Yoxo 2. Demandez un jeton d'accès : `POST https://auth.yoxo.software/oauth2/token`    ```    grant_type=client_credentials    &client_id=votre_client_id    &client_secret=votre_client_secret    &scope=api_access    ``` 3. Incluez le jeton dans l'en-tête Authorization : `Bearer <token>`  ## Filtrage RSQL Utilisez le paramètre de requête `filter` avec la syntaxe RSQL : - **Opérateurs** : `==`, `!=`, `>`, `>=`, `<`, `<=` - **Logique** : `;` (ET), `,` (OU), `()` pour grouper - **Wildcards** : `*` pour contains/startsWith/endsWith - **Exemples** :   - `b>100000` : niveau global > 100000   - `u==*Romain*` : nom d'utilisateur contenant \"Romain\"   - `b>500000;bP<100` : niveau > 500000 ET position < 100   - `(u==*35*,u==*76*)` : nom contenant \"35\" OU \"76\" 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package software.yoxo.client.api;

import software.yoxo.client.invoker.ApiCallback;
import software.yoxo.client.invoker.ApiClient;
import software.yoxo.client.invoker.ApiException;
import software.yoxo.client.invoker.ApiResponse;
import software.yoxo.client.invoker.Configuration;
import software.yoxo.client.invoker.Pair;
import software.yoxo.client.invoker.ProgressRequestBody;
import software.yoxo.client.invoker.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import software.yoxo.client.model.CerealGlobalMarket;
import software.yoxo.client.model.Country;
import software.yoxo.client.model.Enterprise;
import software.yoxo.client.model.Halloween2025;
import java.time.LocalDate;
import software.yoxo.client.model.NoelMegagift2024;
import software.yoxo.client.model.NoelMegagift2025;
import software.yoxo.client.model.PlayerList;
import software.yoxo.client.model.PostQueryBody;
import software.yoxo.client.model.ResearchConfig;
import software.yoxo.client.model.ResearchServer;
import software.yoxo.client.model.Skill;
import software.yoxo.client.model.War;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ApiJavaApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ApiJavaApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ApiJavaApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for getCerealGlobalMarket
     * @param date La date à laquelle on veut récupérer les données du marché des céréales (au format ISO-8601: yyyy-MM-dd) (required)
     * @param javaServer Serveur NationsGlory dont on veut les données. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCerealGlobalMarketCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/cereal_global_market/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCerealGlobalMarketValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getCerealGlobalMarket(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getCerealGlobalMarket(Async)");
        }

        return getCerealGlobalMarketCall(date, javaServer, _callback);

    }

    /**
     * Cereal Global Market
     * Permet d&#39;obtenir les données du marché global des céréales pour un serveur spécifique à une date donnée.  Ces données incluent : - Les graphiques de l&#39;évolution des prix, des ventes et des stocks - L&#39;historique des prix, ventes et stocks par type de céréale - Les prix actuels des céréales  **Fréquence de mise à jour :** Les données sont actualisées tous les jours impairs du mois (environ une fois tous les 2 jours), généralement la nuit.  **Note :** Ces données représentent un objet unique (pas une liste), donc le filtrage et la pagination ne sont pas applicables. 
     * @param date La date à laquelle on veut récupérer les données du marché des céréales (au format ISO-8601: yyyy-MM-dd) (required)
     * @param javaServer Serveur NationsGlory dont on veut les données. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return CerealGlobalMarket
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public CerealGlobalMarket getCerealGlobalMarket(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        ApiResponse<CerealGlobalMarket> localVarResp = getCerealGlobalMarketWithHttpInfo(date, javaServer);
        return localVarResp.getData();
    }

    /**
     * Cereal Global Market
     * Permet d&#39;obtenir les données du marché global des céréales pour un serveur spécifique à une date donnée.  Ces données incluent : - Les graphiques de l&#39;évolution des prix, des ventes et des stocks - L&#39;historique des prix, ventes et stocks par type de céréale - Les prix actuels des céréales  **Fréquence de mise à jour :** Les données sont actualisées tous les jours impairs du mois (environ une fois tous les 2 jours), généralement la nuit.  **Note :** Ces données représentent un objet unique (pas une liste), donc le filtrage et la pagination ne sont pas applicables. 
     * @param date La date à laquelle on veut récupérer les données du marché des céréales (au format ISO-8601: yyyy-MM-dd) (required)
     * @param javaServer Serveur NationsGlory dont on veut les données. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return ApiResponse&lt;CerealGlobalMarket&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CerealGlobalMarket> getCerealGlobalMarketWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        okhttp3.Call localVarCall = getCerealGlobalMarketValidateBeforeCall(date, javaServer, null);
        Type localVarReturnType = new TypeToken<CerealGlobalMarket>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Cereal Global Market (asynchronously)
     * Permet d&#39;obtenir les données du marché global des céréales pour un serveur spécifique à une date donnée.  Ces données incluent : - Les graphiques de l&#39;évolution des prix, des ventes et des stocks - L&#39;historique des prix, ventes et stocks par type de céréale - Les prix actuels des céréales  **Fréquence de mise à jour :** Les données sont actualisées tous les jours impairs du mois (environ une fois tous les 2 jours), généralement la nuit.  **Note :** Ces données représentent un objet unique (pas une liste), donc le filtrage et la pagination ne sont pas applicables. 
     * @param date La date à laquelle on veut récupérer les données du marché des céréales (au format ISO-8601: yyyy-MM-dd) (required)
     * @param javaServer Serveur NationsGlory dont on veut les données. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCerealGlobalMarketAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback<CerealGlobalMarket> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCerealGlobalMarketValidateBeforeCall(date, javaServer, _callback);
        Type localVarReturnType = new TypeToken<CerealGlobalMarket>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCountry
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCountryCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/country/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCountryValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getCountry(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getCountry(Async)");
        }

        return getCountryCall(date, javaServer, _callback);

    }

    /**
     * Country
     * Permet d&#39;obtenir la liste et les détails complets de tous les pays d&#39;un serveur à une date donnée (aucun filtrage possible). Il est possible de spécifier un pays dans l&#39;URL pour récupérer un pays spécifique.  **Données exposées :** - Informations générales (nom, description, niveau, power, claims...) - Relations (alliance, guerres) - Membres (liste, rôles, recrues) - Économie (banque, actions) - Paramètres et permissions  **Fréquence de mise à jour :** Les données sont actualisées tous les jours, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return Country
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Country getCountry(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        ApiResponse<Country> localVarResp = getCountryWithHttpInfo(date, javaServer);
        return localVarResp.getData();
    }

    /**
     * Country
     * Permet d&#39;obtenir la liste et les détails complets de tous les pays d&#39;un serveur à une date donnée (aucun filtrage possible). Il est possible de spécifier un pays dans l&#39;URL pour récupérer un pays spécifique.  **Données exposées :** - Informations générales (nom, description, niveau, power, claims...) - Relations (alliance, guerres) - Membres (liste, rôles, recrues) - Économie (banque, actions) - Paramètres et permissions  **Fréquence de mise à jour :** Les données sont actualisées tous les jours, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return ApiResponse&lt;Country&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Country> getCountryWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        okhttp3.Call localVarCall = getCountryValidateBeforeCall(date, javaServer, null);
        Type localVarReturnType = new TypeToken<Country>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Country (asynchronously)
     * Permet d&#39;obtenir la liste et les détails complets de tous les pays d&#39;un serveur à une date donnée (aucun filtrage possible). Il est possible de spécifier un pays dans l&#39;URL pour récupérer un pays spécifique.  **Données exposées :** - Informations générales (nom, description, niveau, power, claims...) - Relations (alliance, guerres) - Membres (liste, rôles, recrues) - Économie (banque, actions) - Paramètres et permissions  **Fréquence de mise à jour :** Les données sont actualisées tous les jours, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCountryAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback<Country> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCountryValidateBeforeCall(date, javaServer, _callback);
        Type localVarReturnType = new TypeToken<Country>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCountry1
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param country Nom du pays (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCountry1Call(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String country, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/country/{date}/{javaServer}/{country}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()))
            .replace("{" + "country" + "}", localVarApiClient.escapeString(country.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCountry1ValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String country, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getCountry1(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getCountry1(Async)");
        }

        // verify the required parameter 'country' is set
        if (country == null) {
            throw new ApiException("Missing the required parameter 'country' when calling getCountry1(Async)");
        }

        return getCountry1Call(date, javaServer, country, _callback);

    }

    /**
     * Country
     * Permet d&#39;obtenir la liste et les détails complets de tous les pays d&#39;un serveur à une date donnée (aucun filtrage possible). Il est possible de spécifier un pays dans l&#39;URL pour récupérer un pays spécifique.  **Données exposées :** - Informations générales (nom, description, niveau, power, claims...) - Relations (alliance, guerres) - Membres (liste, rôles, recrues) - Économie (banque, actions) - Paramètres et permissions  **Fréquence de mise à jour :** Les données sont actualisées tous les jours, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param country Nom du pays (required)
     * @return Country
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Country getCountry1(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String country) throws ApiException {
        ApiResponse<Country> localVarResp = getCountry1WithHttpInfo(date, javaServer, country);
        return localVarResp.getData();
    }

    /**
     * Country
     * Permet d&#39;obtenir la liste et les détails complets de tous les pays d&#39;un serveur à une date donnée (aucun filtrage possible). Il est possible de spécifier un pays dans l&#39;URL pour récupérer un pays spécifique.  **Données exposées :** - Informations générales (nom, description, niveau, power, claims...) - Relations (alliance, guerres) - Membres (liste, rôles, recrues) - Économie (banque, actions) - Paramètres et permissions  **Fréquence de mise à jour :** Les données sont actualisées tous les jours, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param country Nom du pays (required)
     * @return ApiResponse&lt;Country&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Country> getCountry1WithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String country) throws ApiException {
        okhttp3.Call localVarCall = getCountry1ValidateBeforeCall(date, javaServer, country, null);
        Type localVarReturnType = new TypeToken<Country>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Country (asynchronously)
     * Permet d&#39;obtenir la liste et les détails complets de tous les pays d&#39;un serveur à une date donnée (aucun filtrage possible). Il est possible de spécifier un pays dans l&#39;URL pour récupérer un pays spécifique.  **Données exposées :** - Informations générales (nom, description, niveau, power, claims...) - Relations (alliance, guerres) - Membres (liste, rôles, recrues) - Économie (banque, actions) - Paramètres et permissions  **Fréquence de mise à jour :** Les données sont actualisées tous les jours, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param country Nom du pays (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCountry1Async(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String country, final ApiCallback<Country> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCountry1ValidateBeforeCall(date, javaServer, country, _callback);
        Type localVarReturnType = new TypeToken<Country>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEnterprises
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données d&#39;entreprises. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param enterpriseType Type d&#39;entreprise (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEnterprisesCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable String enterpriseType, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/enterprise/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (enterpriseType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enterpriseType", enterpriseType));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEnterprisesValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable String enterpriseType, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getEnterprises(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getEnterprises(Async)");
        }

        return getEnterprisesCall(date, javaServer, enterpriseType, _callback);

    }

    /**
     * Enterprise
     * Permet d&#39;obtenir la liste de toutes les entreprises sur un serveur à une date donnée. Chaque entreprise contient des champs communs (nom, propriétaire, employés, contrats) et des champs spécifiques selon son type (ex: historique des gains pour les casinos, production pour les centrales électriques). Il est possible de filtrer par nom d&#39;entreprise.  **Types d&#39;entreprises :** - Casino : Entreprises de casino - Electric : Entreprises électriques - Farm : Entreprises agricoles - Petrol : Entreprises pétrolières - Trader : Entreprises de trading - Bet : Entreprises de paris - RealEstate : Entreprises immobilières (location de parcelles) - Build, Engineer, Terraform, Journalist, PVP, Loan, Repair, Lawyer : Entreprises de services  **Fréquence de mise à jour :** Les données sont actualisées tous les lundis matin. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données d&#39;entreprises. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param enterpriseType Type d&#39;entreprise (optional)
     * @return Enterprise
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Enterprise getEnterprises(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable String enterpriseType) throws ApiException {
        ApiResponse<Enterprise> localVarResp = getEnterprisesWithHttpInfo(date, javaServer, enterpriseType);
        return localVarResp.getData();
    }

    /**
     * Enterprise
     * Permet d&#39;obtenir la liste de toutes les entreprises sur un serveur à une date donnée. Chaque entreprise contient des champs communs (nom, propriétaire, employés, contrats) et des champs spécifiques selon son type (ex: historique des gains pour les casinos, production pour les centrales électriques). Il est possible de filtrer par nom d&#39;entreprise.  **Types d&#39;entreprises :** - Casino : Entreprises de casino - Electric : Entreprises électriques - Farm : Entreprises agricoles - Petrol : Entreprises pétrolières - Trader : Entreprises de trading - Bet : Entreprises de paris - RealEstate : Entreprises immobilières (location de parcelles) - Build, Engineer, Terraform, Journalist, PVP, Loan, Repair, Lawyer : Entreprises de services  **Fréquence de mise à jour :** Les données sont actualisées tous les lundis matin. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données d&#39;entreprises. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param enterpriseType Type d&#39;entreprise (optional)
     * @return ApiResponse&lt;Enterprise&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Enterprise> getEnterprisesWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable String enterpriseType) throws ApiException {
        okhttp3.Call localVarCall = getEnterprisesValidateBeforeCall(date, javaServer, enterpriseType, null);
        Type localVarReturnType = new TypeToken<Enterprise>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Enterprise (asynchronously)
     * Permet d&#39;obtenir la liste de toutes les entreprises sur un serveur à une date donnée. Chaque entreprise contient des champs communs (nom, propriétaire, employés, contrats) et des champs spécifiques selon son type (ex: historique des gains pour les casinos, production pour les centrales électriques). Il est possible de filtrer par nom d&#39;entreprise.  **Types d&#39;entreprises :** - Casino : Entreprises de casino - Electric : Entreprises électriques - Farm : Entreprises agricoles - Petrol : Entreprises pétrolières - Trader : Entreprises de trading - Bet : Entreprises de paris - RealEstate : Entreprises immobilières (location de parcelles) - Build, Engineer, Terraform, Journalist, PVP, Loan, Repair, Lawyer : Entreprises de services  **Fréquence de mise à jour :** Les données sont actualisées tous les lundis matin. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données d&#39;entreprises. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param enterpriseType Type d&#39;entreprise (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEnterprisesAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable String enterpriseType, final ApiCallback<Enterprise> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEnterprisesValidateBeforeCall(date, javaServer, enterpriseType, _callback);
        Type localVarReturnType = new TypeToken<Enterprise>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getEnterprises1
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données d&#39;entreprises. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param enterpriseName Nom de l&#39;entreprise (required)
     * @param enterpriseType Type d&#39;entreprise (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEnterprises1Call(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String enterpriseName, @javax.annotation.Nullable String enterpriseType, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/enterprise/{date}/{javaServer}/{enterpriseName}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()))
            .replace("{" + "enterpriseName" + "}", localVarApiClient.escapeString(enterpriseName.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (enterpriseType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("enterpriseType", enterpriseType));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getEnterprises1ValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String enterpriseName, @javax.annotation.Nullable String enterpriseType, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getEnterprises1(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getEnterprises1(Async)");
        }

        // verify the required parameter 'enterpriseName' is set
        if (enterpriseName == null) {
            throw new ApiException("Missing the required parameter 'enterpriseName' when calling getEnterprises1(Async)");
        }

        return getEnterprises1Call(date, javaServer, enterpriseName, enterpriseType, _callback);

    }

    /**
     * Enterprise
     * Permet d&#39;obtenir la liste de toutes les entreprises sur un serveur à une date donnée. Chaque entreprise contient des champs communs (nom, propriétaire, employés, contrats) et des champs spécifiques selon son type (ex: historique des gains pour les casinos, production pour les centrales électriques). Il est possible de filtrer par nom d&#39;entreprise.  **Types d&#39;entreprises :** - Casino : Entreprises de casino - Electric : Entreprises électriques - Farm : Entreprises agricoles - Petrol : Entreprises pétrolières - Trader : Entreprises de trading - Bet : Entreprises de paris - RealEstate : Entreprises immobilières (location de parcelles) - Build, Engineer, Terraform, Journalist, PVP, Loan, Repair, Lawyer : Entreprises de services  **Fréquence de mise à jour :** Les données sont actualisées tous les lundis matin. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données d&#39;entreprises. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param enterpriseName Nom de l&#39;entreprise (required)
     * @param enterpriseType Type d&#39;entreprise (optional)
     * @return Enterprise
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Enterprise getEnterprises1(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String enterpriseName, @javax.annotation.Nullable String enterpriseType) throws ApiException {
        ApiResponse<Enterprise> localVarResp = getEnterprises1WithHttpInfo(date, javaServer, enterpriseName, enterpriseType);
        return localVarResp.getData();
    }

    /**
     * Enterprise
     * Permet d&#39;obtenir la liste de toutes les entreprises sur un serveur à une date donnée. Chaque entreprise contient des champs communs (nom, propriétaire, employés, contrats) et des champs spécifiques selon son type (ex: historique des gains pour les casinos, production pour les centrales électriques). Il est possible de filtrer par nom d&#39;entreprise.  **Types d&#39;entreprises :** - Casino : Entreprises de casino - Electric : Entreprises électriques - Farm : Entreprises agricoles - Petrol : Entreprises pétrolières - Trader : Entreprises de trading - Bet : Entreprises de paris - RealEstate : Entreprises immobilières (location de parcelles) - Build, Engineer, Terraform, Journalist, PVP, Loan, Repair, Lawyer : Entreprises de services  **Fréquence de mise à jour :** Les données sont actualisées tous les lundis matin. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données d&#39;entreprises. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param enterpriseName Nom de l&#39;entreprise (required)
     * @param enterpriseType Type d&#39;entreprise (optional)
     * @return ApiResponse&lt;Enterprise&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Enterprise> getEnterprises1WithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String enterpriseName, @javax.annotation.Nullable String enterpriseType) throws ApiException {
        okhttp3.Call localVarCall = getEnterprises1ValidateBeforeCall(date, javaServer, enterpriseName, enterpriseType, null);
        Type localVarReturnType = new TypeToken<Enterprise>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Enterprise (asynchronously)
     * Permet d&#39;obtenir la liste de toutes les entreprises sur un serveur à une date donnée. Chaque entreprise contient des champs communs (nom, propriétaire, employés, contrats) et des champs spécifiques selon son type (ex: historique des gains pour les casinos, production pour les centrales électriques). Il est possible de filtrer par nom d&#39;entreprise.  **Types d&#39;entreprises :** - Casino : Entreprises de casino - Electric : Entreprises électriques - Farm : Entreprises agricoles - Petrol : Entreprises pétrolières - Trader : Entreprises de trading - Bet : Entreprises de paris - RealEstate : Entreprises immobilières (location de parcelles) - Build, Engineer, Terraform, Journalist, PVP, Loan, Repair, Lawyer : Entreprises de services  **Fréquence de mise à jour :** Les données sont actualisées tous les lundis matin. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données d&#39;entreprises. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param enterpriseName Nom de l&#39;entreprise (required)
     * @param enterpriseType Type d&#39;entreprise (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getEnterprises1Async(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String enterpriseName, @javax.annotation.Nullable String enterpriseType, final ApiCallback<Enterprise> _callback) throws ApiException {

        okhttp3.Call localVarCall = getEnterprises1ValidateBeforeCall(date, javaServer, enterpriseName, enterpriseType, _callback);
        Type localVarReturnType = new TypeToken<Enterprise>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getHalloween2025
     * @param date Date des données au format ISO-8601 (yyyy-MM-dd). Événement actif du 21/10/2025 au 13/11/2025, données actualisées quotidiennement (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHalloween2025Call(@javax.annotation.Nonnull LocalDate date, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/halloween-2025/{date}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getHalloween2025ValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getHalloween2025(Async)");
        }

        return getHalloween2025Call(date, _callback);

    }

    /**
     * Halloween 2025
     * Permet d&#39;obtenir les statistiques des joueurs du top 50 de l&#39;événement Halloween 2025 \&quot;Demon&#39;s Return\&quot; à une date donnée (aucun filtrage possible). Seuls les joueurs du top 50 interserveur sont accessibles (limitation du serveur).  **À propos de l&#39;événement :** L&#39;événement \&quot;Demon&#39;s Return\&quot; est un événement global interserveur où l&#39;objectif est de collecter des âmes et tuer des démons pour empêcher l&#39;invasion démoniaque. Le classement est identique sur tous les serveurs puisqu&#39;il s&#39;agit d&#39;un événement global à NationsGlory.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 21/10/2025 au 04/11/2025), généralement la nuit.  **Documentation :** Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/halloween-2025-demons-return-1lfsu05/ 
     * @param date Date des données au format ISO-8601 (yyyy-MM-dd). Événement actif du 21/10/2025 au 13/11/2025, données actualisées quotidiennement (required)
     * @return Halloween2025
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Halloween2025 getHalloween2025(@javax.annotation.Nonnull LocalDate date) throws ApiException {
        ApiResponse<Halloween2025> localVarResp = getHalloween2025WithHttpInfo(date);
        return localVarResp.getData();
    }

    /**
     * Halloween 2025
     * Permet d&#39;obtenir les statistiques des joueurs du top 50 de l&#39;événement Halloween 2025 \&quot;Demon&#39;s Return\&quot; à une date donnée (aucun filtrage possible). Seuls les joueurs du top 50 interserveur sont accessibles (limitation du serveur).  **À propos de l&#39;événement :** L&#39;événement \&quot;Demon&#39;s Return\&quot; est un événement global interserveur où l&#39;objectif est de collecter des âmes et tuer des démons pour empêcher l&#39;invasion démoniaque. Le classement est identique sur tous les serveurs puisqu&#39;il s&#39;agit d&#39;un événement global à NationsGlory.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 21/10/2025 au 04/11/2025), généralement la nuit.  **Documentation :** Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/halloween-2025-demons-return-1lfsu05/ 
     * @param date Date des données au format ISO-8601 (yyyy-MM-dd). Événement actif du 21/10/2025 au 13/11/2025, données actualisées quotidiennement (required)
     * @return ApiResponse&lt;Halloween2025&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Halloween2025> getHalloween2025WithHttpInfo(@javax.annotation.Nonnull LocalDate date) throws ApiException {
        okhttp3.Call localVarCall = getHalloween2025ValidateBeforeCall(date, null);
        Type localVarReturnType = new TypeToken<Halloween2025>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Halloween 2025 (asynchronously)
     * Permet d&#39;obtenir les statistiques des joueurs du top 50 de l&#39;événement Halloween 2025 \&quot;Demon&#39;s Return\&quot; à une date donnée (aucun filtrage possible). Seuls les joueurs du top 50 interserveur sont accessibles (limitation du serveur).  **À propos de l&#39;événement :** L&#39;événement \&quot;Demon&#39;s Return\&quot; est un événement global interserveur où l&#39;objectif est de collecter des âmes et tuer des démons pour empêcher l&#39;invasion démoniaque. Le classement est identique sur tous les serveurs puisqu&#39;il s&#39;agit d&#39;un événement global à NationsGlory.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 21/10/2025 au 04/11/2025), généralement la nuit.  **Documentation :** Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/halloween-2025-demons-return-1lfsu05/ 
     * @param date Date des données au format ISO-8601 (yyyy-MM-dd). Événement actif du 21/10/2025 au 13/11/2025, données actualisées quotidiennement (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getHalloween2025Async(@javax.annotation.Nonnull LocalDate date, final ApiCallback<Halloween2025> _callback) throws ApiException {

        okhttp3.Call localVarCall = getHalloween2025ValidateBeforeCall(date, _callback);
        Type localVarReturnType = new TypeToken<Halloween2025>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNoelMegagift2024
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNoelMegagift2024Call(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/noelmegagift-2024";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNoelMegagift2024ValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getNoelMegagift2024Call(_callback);

    }

    /**
     * Noël Megagift 2024
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement \&quot;The Key Guardian\&quot; (Noël 2024).  **À propos de l&#39;événement :** L&#39;événement \&quot;The Key Guardian\&quot; est l&#39;événement de Noël 2024 où les joueurs doivent à récupérer 9 clés perdues pour assembler une Méga Clé et débloquer le Mega Cadeau. Chaque tirage du Mega Cadeau offre jusqu&#39;à 4 récompenses selon le nombre de joueurs présents (armes exclusives, plans rares, items légendaires, cosmétiques).  **Période de l&#39;événement :** Du 24/12/2024 au 12/01/2025  **Données exposées :** Chaque entrée représente un tirage individuel du Mega Gift par un joueur, avec les items obtenus et la date/heure du tirage. 
     * @return NoelMegagift2024
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public NoelMegagift2024 getNoelMegagift2024() throws ApiException {
        ApiResponse<NoelMegagift2024> localVarResp = getNoelMegagift2024WithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Noël Megagift 2024
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement \&quot;The Key Guardian\&quot; (Noël 2024).  **À propos de l&#39;événement :** L&#39;événement \&quot;The Key Guardian\&quot; est l&#39;événement de Noël 2024 où les joueurs doivent à récupérer 9 clés perdues pour assembler une Méga Clé et débloquer le Mega Cadeau. Chaque tirage du Mega Cadeau offre jusqu&#39;à 4 récompenses selon le nombre de joueurs présents (armes exclusives, plans rares, items légendaires, cosmétiques).  **Période de l&#39;événement :** Du 24/12/2024 au 12/01/2025  **Données exposées :** Chaque entrée représente un tirage individuel du Mega Gift par un joueur, avec les items obtenus et la date/heure du tirage. 
     * @return ApiResponse&lt;NoelMegagift2024&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NoelMegagift2024> getNoelMegagift2024WithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getNoelMegagift2024ValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<NoelMegagift2024>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Noël Megagift 2024 (asynchronously)
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement \&quot;The Key Guardian\&quot; (Noël 2024).  **À propos de l&#39;événement :** L&#39;événement \&quot;The Key Guardian\&quot; est l&#39;événement de Noël 2024 où les joueurs doivent à récupérer 9 clés perdues pour assembler une Méga Clé et débloquer le Mega Cadeau. Chaque tirage du Mega Cadeau offre jusqu&#39;à 4 récompenses selon le nombre de joueurs présents (armes exclusives, plans rares, items légendaires, cosmétiques).  **Période de l&#39;événement :** Du 24/12/2024 au 12/01/2025  **Données exposées :** Chaque entrée représente un tirage individuel du Mega Gift par un joueur, avec les items obtenus et la date/heure du tirage. 
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNoelMegagift2024Async(final ApiCallback<NoelMegagift2024> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNoelMegagift2024ValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<NoelMegagift2024>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getNoelMegagift2025
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNoelMegagift2025Call(@javax.annotation.Nonnull LocalDate date, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/noelmegagift-2025/{date}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNoelMegagift2025ValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getNoelMegagift2025(Async)");
        }

        return getNoelMegagift2025Call(date, _callback);

    }

    /**
     * Noël Megagift 2025
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement de Noël 2025.  **À propos de l&#39;événement :** Événement interserveur où les joueurs peuvent obtenir des récompenses exclusives via le Mega Cadeau. Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/lile-du-pere-noel-rv8x0t/#2-le-mega-cadeau-recompense-ultime  **Période de l&#39;événement :** Du 14/12/2025 au 06/01/2026  **Données exposées :** Chaque entrée représente un tirage individuel du Mega cadeau par un joueur, avec les items obtenus et la date/heure du tirage.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 14/12/2025 au 06/01/2026), généralement la nuit. 
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @return NoelMegagift2025
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public NoelMegagift2025 getNoelMegagift2025(@javax.annotation.Nonnull LocalDate date) throws ApiException {
        ApiResponse<NoelMegagift2025> localVarResp = getNoelMegagift2025WithHttpInfo(date);
        return localVarResp.getData();
    }

    /**
     * Noël Megagift 2025
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement de Noël 2025.  **À propos de l&#39;événement :** Événement interserveur où les joueurs peuvent obtenir des récompenses exclusives via le Mega Cadeau. Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/lile-du-pere-noel-rv8x0t/#2-le-mega-cadeau-recompense-ultime  **Période de l&#39;événement :** Du 14/12/2025 au 06/01/2026  **Données exposées :** Chaque entrée représente un tirage individuel du Mega cadeau par un joueur, avec les items obtenus et la date/heure du tirage.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 14/12/2025 au 06/01/2026), généralement la nuit. 
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @return ApiResponse&lt;NoelMegagift2025&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NoelMegagift2025> getNoelMegagift2025WithHttpInfo(@javax.annotation.Nonnull LocalDate date) throws ApiException {
        okhttp3.Call localVarCall = getNoelMegagift2025ValidateBeforeCall(date, null);
        Type localVarReturnType = new TypeToken<NoelMegagift2025>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Noël Megagift 2025 (asynchronously)
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement de Noël 2025.  **À propos de l&#39;événement :** Événement interserveur où les joueurs peuvent obtenir des récompenses exclusives via le Mega Cadeau. Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/lile-du-pere-noel-rv8x0t/#2-le-mega-cadeau-recompense-ultime  **Période de l&#39;événement :** Du 14/12/2025 au 06/01/2026  **Données exposées :** Chaque entrée représente un tirage individuel du Mega cadeau par un joueur, avec les items obtenus et la date/heure du tirage.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 14/12/2025 au 06/01/2026), généralement la nuit. 
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getNoelMegagift2025Async(@javax.annotation.Nonnull LocalDate date, final ApiCallback<NoelMegagift2025> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNoelMegagift2025ValidateBeforeCall(date, _callback);
        Type localVarReturnType = new TypeToken<NoelMegagift2025>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPlayerList
     * @param date La date à laquelle on veut récupérer la liste des joueurs (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut la liste des joueurs. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPlayerListCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/player-list/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPlayerListValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getPlayerList(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getPlayerList(Async)");
        }

        return getPlayerListCall(date, javaServer, _callback);

    }

    /**
     * Player List
     * Permet d&#39;obtenir la liste des joueurs s&#39;étant connectés au moins une fois au cours des 14 derniers jours sur un serveur à une date donnée (aucun filtrage possible).  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date La date à laquelle on veut récupérer la liste des joueurs (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut la liste des joueurs. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return PlayerList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PlayerList getPlayerList(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        ApiResponse<PlayerList> localVarResp = getPlayerListWithHttpInfo(date, javaServer);
        return localVarResp.getData();
    }

    /**
     * Player List
     * Permet d&#39;obtenir la liste des joueurs s&#39;étant connectés au moins une fois au cours des 14 derniers jours sur un serveur à une date donnée (aucun filtrage possible).  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date La date à laquelle on veut récupérer la liste des joueurs (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut la liste des joueurs. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return ApiResponse&lt;PlayerList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PlayerList> getPlayerListWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        okhttp3.Call localVarCall = getPlayerListValidateBeforeCall(date, javaServer, null);
        Type localVarReturnType = new TypeToken<PlayerList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Player List (asynchronously)
     * Permet d&#39;obtenir la liste des joueurs s&#39;étant connectés au moins une fois au cours des 14 derniers jours sur un serveur à une date donnée (aucun filtrage possible).  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date La date à laquelle on veut récupérer la liste des joueurs (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut la liste des joueurs. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPlayerListAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback<PlayerList> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPlayerListValidateBeforeCall(date, javaServer, _callback);
        Type localVarReturnType = new TypeToken<PlayerList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getResearchConfig
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getResearchConfigCall(@javax.annotation.Nonnull LocalDate date, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/research/{date}/config"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getResearchConfigValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getResearchConfig(Async)");
        }

        return getResearchConfigCall(date, _callback);

    }

    /**
     * Research Config
     * Permet d&#39;obtenir la configuration globale de tous les domaines de recherche disponibles dans NationsGlory. Cette configuration est identique pour tous les serveurs et définit les niveaux, conditions et récompenses.  **Contenu de la configuration :** - Noms et descriptions des domaines de recherche - Niveaux maximum par domaine - Conditions requises par niveau - Récompenses obtenues par niveau - Durées de recherche  **Fréquence de mise à jour :** Les données sont actualisées tous les jours impairs du mois (environ une fois tous les 2 jours), généralement la nuit. 
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @return ResearchConfig
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ResearchConfig getResearchConfig(@javax.annotation.Nonnull LocalDate date) throws ApiException {
        ApiResponse<ResearchConfig> localVarResp = getResearchConfigWithHttpInfo(date);
        return localVarResp.getData();
    }

    /**
     * Research Config
     * Permet d&#39;obtenir la configuration globale de tous les domaines de recherche disponibles dans NationsGlory. Cette configuration est identique pour tous les serveurs et définit les niveaux, conditions et récompenses.  **Contenu de la configuration :** - Noms et descriptions des domaines de recherche - Niveaux maximum par domaine - Conditions requises par niveau - Récompenses obtenues par niveau - Durées de recherche  **Fréquence de mise à jour :** Les données sont actualisées tous les jours impairs du mois (environ une fois tous les 2 jours), généralement la nuit. 
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @return ApiResponse&lt;ResearchConfig&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResearchConfig> getResearchConfigWithHttpInfo(@javax.annotation.Nonnull LocalDate date) throws ApiException {
        okhttp3.Call localVarCall = getResearchConfigValidateBeforeCall(date, null);
        Type localVarReturnType = new TypeToken<ResearchConfig>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Research Config (asynchronously)
     * Permet d&#39;obtenir la configuration globale de tous les domaines de recherche disponibles dans NationsGlory. Cette configuration est identique pour tous les serveurs et définit les niveaux, conditions et récompenses.  **Contenu de la configuration :** - Noms et descriptions des domaines de recherche - Niveaux maximum par domaine - Conditions requises par niveau - Récompenses obtenues par niveau - Durées de recherche  **Fréquence de mise à jour :** Les données sont actualisées tous les jours impairs du mois (environ une fois tous les 2 jours), généralement la nuit. 
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getResearchConfigAsync(@javax.annotation.Nonnull LocalDate date, final ApiCallback<ResearchConfig> _callback) throws ApiException {

        okhttp3.Call localVarCall = getResearchConfigValidateBeforeCall(date, _callback);
        Type localVarReturnType = new TypeToken<ResearchConfig>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getResearchServer
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de R&amp;D. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getResearchServerCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/research/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getResearchServerValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getResearchServer(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getResearchServer(Async)");
        }

        return getResearchServerCall(date, javaServer, _callback);

    }

    /**
     * Research Server
     * Permet d&#39;obtenir les niveaux de recherche actuels de tous les pays d&#39;un serveur à une date donnée (sans filtrage).  **Données exposées :** - Niveaux actuels de recherche par domaine pour chaque pays - Dernière recherche complétée par chaque pays - Valeurs actuelles des conditions de recherche  **Fréquence de mise à jour :** Les données sont actualisées tous les jours impairs du mois (environ une fois tous les 2 jours), généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de R&amp;D. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return ResearchServer
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ResearchServer getResearchServer(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        ApiResponse<ResearchServer> localVarResp = getResearchServerWithHttpInfo(date, javaServer);
        return localVarResp.getData();
    }

    /**
     * Research Server
     * Permet d&#39;obtenir les niveaux de recherche actuels de tous les pays d&#39;un serveur à une date donnée (sans filtrage).  **Données exposées :** - Niveaux actuels de recherche par domaine pour chaque pays - Dernière recherche complétée par chaque pays - Valeurs actuelles des conditions de recherche  **Fréquence de mise à jour :** Les données sont actualisées tous les jours impairs du mois (environ une fois tous les 2 jours), généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de R&amp;D. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return ApiResponse&lt;ResearchServer&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResearchServer> getResearchServerWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        okhttp3.Call localVarCall = getResearchServerValidateBeforeCall(date, javaServer, null);
        Type localVarReturnType = new TypeToken<ResearchServer>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Research Server (asynchronously)
     * Permet d&#39;obtenir les niveaux de recherche actuels de tous les pays d&#39;un serveur à une date donnée (sans filtrage).  **Données exposées :** - Niveaux actuels de recherche par domaine pour chaque pays - Dernière recherche complétée par chaque pays - Valeurs actuelles des conditions de recherche  **Fréquence de mise à jour :** Les données sont actualisées tous les jours impairs du mois (environ une fois tous les 2 jours), généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de R&amp;D. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getResearchServerAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback<ResearchServer> _callback) throws ApiException {

        okhttp3.Call localVarCall = getResearchServerValidateBeforeCall(date, javaServer, _callback);
        Type localVarReturnType = new TypeToken<ResearchServer>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSkill
     * @param date La date à laquelle on veut récupéré les skills (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les skills. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSkillCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/skill/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSkillValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getSkill(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getSkill(Async)");
        }

        return getSkillCall(date, javaServer, _callback);

    }

    /**
     * Skill
     * Permet d&#39;obtenir les compétences des joueurs présents dans au moins 1 top 50 compétences sur un serveur à une date donnée (aucun filtrage possible). Seuls les joueurs figurant dans le top 50 d&#39;au moins une compétence sur le serveur sont inclus pour éviter de surcharger les serveurs.  **Fréquence de mise à jour :** Les données sont actualisées tous les jours pairs du mois (environ une fois tous les 2 jours), généralement la nuit.  **Documentation :** Plus d&#39;informations sur les compétences/skills : https://wiki.nationsglory.fr/fr/article/les-competences-java-1shixp7/ 
     * @param date La date à laquelle on veut récupéré les skills (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les skills. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return Skill
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Skill getSkill(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        ApiResponse<Skill> localVarResp = getSkillWithHttpInfo(date, javaServer);
        return localVarResp.getData();
    }

    /**
     * Skill
     * Permet d&#39;obtenir les compétences des joueurs présents dans au moins 1 top 50 compétences sur un serveur à une date donnée (aucun filtrage possible). Seuls les joueurs figurant dans le top 50 d&#39;au moins une compétence sur le serveur sont inclus pour éviter de surcharger les serveurs.  **Fréquence de mise à jour :** Les données sont actualisées tous les jours pairs du mois (environ une fois tous les 2 jours), généralement la nuit.  **Documentation :** Plus d&#39;informations sur les compétences/skills : https://wiki.nationsglory.fr/fr/article/les-competences-java-1shixp7/ 
     * @param date La date à laquelle on veut récupéré les skills (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les skills. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return ApiResponse&lt;Skill&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Skill> getSkillWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        okhttp3.Call localVarCall = getSkillValidateBeforeCall(date, javaServer, null);
        Type localVarReturnType = new TypeToken<Skill>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Skill (asynchronously)
     * Permet d&#39;obtenir les compétences des joueurs présents dans au moins 1 top 50 compétences sur un serveur à une date donnée (aucun filtrage possible). Seuls les joueurs figurant dans le top 50 d&#39;au moins une compétence sur le serveur sont inclus pour éviter de surcharger les serveurs.  **Fréquence de mise à jour :** Les données sont actualisées tous les jours pairs du mois (environ une fois tous les 2 jours), généralement la nuit.  **Documentation :** Plus d&#39;informations sur les compétences/skills : https://wiki.nationsglory.fr/fr/article/les-competences-java-1shixp7/ 
     * @param date La date à laquelle on veut récupéré les skills (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les skills. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSkillAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback<Skill> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSkillValidateBeforeCall(date, javaServer, _callback);
        Type localVarReturnType = new TypeToken<Skill>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getWar
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWarCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/war/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWarValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getWar(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getWar(Async)");
        }

        return getWarCall(date, javaServer, _callback);

    }

    /**
     * War
     * Permet d&#39;obtenir la liste des guerres (en cours ou terminées) d&#39;un serveur à une date donnée. Il est possible de spécifier un warId dans l&#39;URL pour récupérer une guerre spécifique.  **Données exposées :** - Identifiant, dates (déclaration, début), raison - Participants (attaquant, défenseur) avec détails (pays, points missiles, progression...) - Conditions de victoire - Récompenses - Détails des assauts et missiles lancés  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return War
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public War getWar(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        ApiResponse<War> localVarResp = getWarWithHttpInfo(date, javaServer);
        return localVarResp.getData();
    }

    /**
     * War
     * Permet d&#39;obtenir la liste des guerres (en cours ou terminées) d&#39;un serveur à une date donnée. Il est possible de spécifier un warId dans l&#39;URL pour récupérer une guerre spécifique.  **Données exposées :** - Identifiant, dates (déclaration, début), raison - Participants (attaquant, défenseur) avec détails (pays, points missiles, progression...) - Conditions de victoire - Récompenses - Détails des assauts et missiles lancés  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @return ApiResponse&lt;War&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<War> getWarWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer) throws ApiException {
        okhttp3.Call localVarCall = getWarValidateBeforeCall(date, javaServer, null);
        Type localVarReturnType = new TypeToken<War>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * War (asynchronously)
     * Permet d&#39;obtenir la liste des guerres (en cours ou terminées) d&#39;un serveur à une date donnée. Il est possible de spécifier un warId dans l&#39;URL pour récupérer une guerre spécifique.  **Données exposées :** - Identifiant, dates (déclaration, début), raison - Participants (attaquant, défenseur) avec détails (pays, points missiles, progression...) - Conditions de victoire - Récompenses - Détails des assauts et missiles lancés  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWarAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, final ApiCallback<War> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWarValidateBeforeCall(date, javaServer, _callback);
        Type localVarReturnType = new TypeToken<War>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getWar1
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param warId Identifiant de la guerre (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWar1Call(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String warId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v2/java/war/{date}/{javaServer}/{warId}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()))
            .replace("{" + "warId" + "}", localVarApiClient.escapeString(warId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWar1ValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String warId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling getWar1(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling getWar1(Async)");
        }

        // verify the required parameter 'warId' is set
        if (warId == null) {
            throw new ApiException("Missing the required parameter 'warId' when calling getWar1(Async)");
        }

        return getWar1Call(date, javaServer, warId, _callback);

    }

    /**
     * War
     * Permet d&#39;obtenir la liste des guerres (en cours ou terminées) d&#39;un serveur à une date donnée. Il est possible de spécifier un warId dans l&#39;URL pour récupérer une guerre spécifique.  **Données exposées :** - Identifiant, dates (déclaration, début), raison - Participants (attaquant, défenseur) avec détails (pays, points missiles, progression...) - Conditions de victoire - Récompenses - Détails des assauts et missiles lancés  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param warId Identifiant de la guerre (required)
     * @return War
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public War getWar1(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String warId) throws ApiException {
        ApiResponse<War> localVarResp = getWar1WithHttpInfo(date, javaServer, warId);
        return localVarResp.getData();
    }

    /**
     * War
     * Permet d&#39;obtenir la liste des guerres (en cours ou terminées) d&#39;un serveur à une date donnée. Il est possible de spécifier un warId dans l&#39;URL pour récupérer une guerre spécifique.  **Données exposées :** - Identifiant, dates (déclaration, début), raison - Participants (attaquant, défenseur) avec détails (pays, points missiles, progression...) - Conditions de victoire - Récompenses - Détails des assauts et missiles lancés  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param warId Identifiant de la guerre (required)
     * @return ApiResponse&lt;War&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<War> getWar1WithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String warId) throws ApiException {
        okhttp3.Call localVarCall = getWar1ValidateBeforeCall(date, javaServer, warId, null);
        Type localVarReturnType = new TypeToken<War>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * War (asynchronously)
     * Permet d&#39;obtenir la liste des guerres (en cours ou terminées) d&#39;un serveur à une date donnée. Il est possible de spécifier un warId dans l&#39;URL pour récupérer une guerre spécifique.  **Données exposées :** - Identifiant, dates (déclaration, début), raison - Participants (attaquant, défenseur) avec détails (pays, points missiles, progression...) - Conditions de victoire - Récompenses - Détails des assauts et missiles lancés  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param warId Identifiant de la guerre (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWar1Async(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nonnull String warId, final ApiCallback<War> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWar1ValidateBeforeCall(date, javaServer, warId, _callback);
        Type localVarReturnType = new TypeToken<War>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postCountry
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postCountryCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postQueryBody;

        // create path and map variables
        String localVarPath = "/v2/java/country/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postCountryValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling postCountry(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling postCountry(Async)");
        }

        return postCountryCall(date, javaServer, postQueryBody, _callback);

    }

    /**
     * Country
     * Permet d&#39;obtenir la liste et les détails complets de tous les pays d&#39;un serveur à une date donnée (avec filtrage possible).  **Données exposées :** - Informations générales (nom, description, niveau, power, claims...) - Relations (alliance, guerres) - Membres (liste, rôles, recrues) - Économie (banque, actions) - Paramètres et permissions  **Fréquence de mise à jour :** Les données sont actualisées tous les jours, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return Country
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Country postCountry(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        ApiResponse<Country> localVarResp = postCountryWithHttpInfo(date, javaServer, postQueryBody);
        return localVarResp.getData();
    }

    /**
     * Country
     * Permet d&#39;obtenir la liste et les détails complets de tous les pays d&#39;un serveur à une date donnée (avec filtrage possible).  **Données exposées :** - Informations générales (nom, description, niveau, power, claims...) - Relations (alliance, guerres) - Membres (liste, rôles, recrues) - Économie (banque, actions) - Paramètres et permissions  **Fréquence de mise à jour :** Les données sont actualisées tous les jours, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return ApiResponse&lt;Country&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Country> postCountryWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        okhttp3.Call localVarCall = postCountryValidateBeforeCall(date, javaServer, postQueryBody, null);
        Type localVarReturnType = new TypeToken<Country>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Country (asynchronously)
     * Permet d&#39;obtenir la liste et les détails complets de tous les pays d&#39;un serveur à une date donnée (avec filtrage possible).  **Données exposées :** - Informations générales (nom, description, niveau, power, claims...) - Relations (alliance, guerres) - Membres (liste, rôles, recrues) - Économie (banque, actions) - Paramètres et permissions  **Fréquence de mise à jour :** Les données sont actualisées tous les jours, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données des pays. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postCountryAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback<Country> _callback) throws ApiException {

        okhttp3.Call localVarCall = postCountryValidateBeforeCall(date, javaServer, postQueryBody, _callback);
        Type localVarReturnType = new TypeToken<Country>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postEnterprises
     * @param date Date des données (format ISO-8601: yyyy-MM-dd) (required)
     * @param javaServer Serveur NationsGlory (required)
     * @param postQueryBody  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postEnterprisesCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postQueryBody;

        // create path and map variables
        String localVarPath = "/v2/java/enterprise/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postEnterprisesValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling postEnterprises(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling postEnterprises(Async)");
        }

        return postEnterprisesCall(date, javaServer, postQueryBody, _callback);

    }

    /**
     * Enterprise
     * Permet d&#39;obtenir la liste de toutes les entreprises sur un serveur à une date donnée. Chaque entreprise contient des champs communs (nom, propriétaire, employés, contrats) et des champs spécifiques selon son type (ex: historique des gains pour les casinos, production pour les centrales électriques).  **Types d&#39;entreprises :** - Casino : Entreprises de casino - Electric : Entreprises électriques - Farm : Entreprises agricoles - Petrol : Entreprises pétrolières - Trader : Entreprises de trading - Bet : Entreprises de paris - RealEstate : Entreprises immobilières (location de parcelles) - Build, Engineer, Terraform, Journalist, PVP, Loan, Repair, Lawyer : Entreprises de services  **Fréquence de mise à jour :** Les données sont actualisées tous les lundis matin. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd) (required)
     * @param javaServer Serveur NationsGlory (required)
     * @param postQueryBody  (optional)
     * @return Enterprise
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Enterprise postEnterprises(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        ApiResponse<Enterprise> localVarResp = postEnterprisesWithHttpInfo(date, javaServer, postQueryBody);
        return localVarResp.getData();
    }

    /**
     * Enterprise
     * Permet d&#39;obtenir la liste de toutes les entreprises sur un serveur à une date donnée. Chaque entreprise contient des champs communs (nom, propriétaire, employés, contrats) et des champs spécifiques selon son type (ex: historique des gains pour les casinos, production pour les centrales électriques).  **Types d&#39;entreprises :** - Casino : Entreprises de casino - Electric : Entreprises électriques - Farm : Entreprises agricoles - Petrol : Entreprises pétrolières - Trader : Entreprises de trading - Bet : Entreprises de paris - RealEstate : Entreprises immobilières (location de parcelles) - Build, Engineer, Terraform, Journalist, PVP, Loan, Repair, Lawyer : Entreprises de services  **Fréquence de mise à jour :** Les données sont actualisées tous les lundis matin. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd) (required)
     * @param javaServer Serveur NationsGlory (required)
     * @param postQueryBody  (optional)
     * @return ApiResponse&lt;Enterprise&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Enterprise> postEnterprisesWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        okhttp3.Call localVarCall = postEnterprisesValidateBeforeCall(date, javaServer, postQueryBody, null);
        Type localVarReturnType = new TypeToken<Enterprise>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Enterprise (asynchronously)
     * Permet d&#39;obtenir la liste de toutes les entreprises sur un serveur à une date donnée. Chaque entreprise contient des champs communs (nom, propriétaire, employés, contrats) et des champs spécifiques selon son type (ex: historique des gains pour les casinos, production pour les centrales électriques).  **Types d&#39;entreprises :** - Casino : Entreprises de casino - Electric : Entreprises électriques - Farm : Entreprises agricoles - Petrol : Entreprises pétrolières - Trader : Entreprises de trading - Bet : Entreprises de paris - RealEstate : Entreprises immobilières (location de parcelles) - Build, Engineer, Terraform, Journalist, PVP, Loan, Repair, Lawyer : Entreprises de services  **Fréquence de mise à jour :** Les données sont actualisées tous les lundis matin. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd) (required)
     * @param javaServer Serveur NationsGlory (required)
     * @param postQueryBody  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postEnterprisesAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback<Enterprise> _callback) throws ApiException {

        okhttp3.Call localVarCall = postEnterprisesValidateBeforeCall(date, javaServer, postQueryBody, _callback);
        Type localVarReturnType = new TypeToken<Enterprise>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postHalloween2025
     * @param date Date des données au format ISO-8601 (yyyy-MM-dd). Événement actif du 21/10/2025 au 13/11/2025, données actualisées quotidiennement (required)
     * @param postQueryBody  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postHalloween2025Call(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postQueryBody;

        // create path and map variables
        String localVarPath = "/v2/java/halloween-2025/{date}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postHalloween2025ValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling postHalloween2025(Async)");
        }

        return postHalloween2025Call(date, postQueryBody, _callback);

    }

    /**
     * Halloween 2025
     * Permet d&#39;obtenir les statistiques des joueurs du top 50 de l&#39;événement Halloween 2025 \&quot;Demon&#39;s Return\&quot; à une date donnée (avec filtrage possible). Seuls les joueurs du top 50 interserveur sont disponibles (limitation du serveur).  **À propos de l&#39;événement :** L&#39;événement \&quot;Demon&#39;s Return\&quot; est un événement global interserveur où l&#39;objectif est de collecter des âmes et tuer des démons pour empêcher l&#39;invasion démoniaque. Le classement est identique sur tous les serveurs puisqu&#39;il s&#39;agit d&#39;un événement global à NationsGlory.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 21/10/2025 au 04/11/2025), généralement la nuit.  **Documentation :** Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/halloween-2025-demons-return-1lfsu05/ 
     * @param date Date des données au format ISO-8601 (yyyy-MM-dd). Événement actif du 21/10/2025 au 13/11/2025, données actualisées quotidiennement (required)
     * @param postQueryBody  (optional)
     * @return Halloween2025
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Halloween2025 postHalloween2025(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        ApiResponse<Halloween2025> localVarResp = postHalloween2025WithHttpInfo(date, postQueryBody);
        return localVarResp.getData();
    }

    /**
     * Halloween 2025
     * Permet d&#39;obtenir les statistiques des joueurs du top 50 de l&#39;événement Halloween 2025 \&quot;Demon&#39;s Return\&quot; à une date donnée (avec filtrage possible). Seuls les joueurs du top 50 interserveur sont disponibles (limitation du serveur).  **À propos de l&#39;événement :** L&#39;événement \&quot;Demon&#39;s Return\&quot; est un événement global interserveur où l&#39;objectif est de collecter des âmes et tuer des démons pour empêcher l&#39;invasion démoniaque. Le classement est identique sur tous les serveurs puisqu&#39;il s&#39;agit d&#39;un événement global à NationsGlory.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 21/10/2025 au 04/11/2025), généralement la nuit.  **Documentation :** Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/halloween-2025-demons-return-1lfsu05/ 
     * @param date Date des données au format ISO-8601 (yyyy-MM-dd). Événement actif du 21/10/2025 au 13/11/2025, données actualisées quotidiennement (required)
     * @param postQueryBody  (optional)
     * @return ApiResponse&lt;Halloween2025&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Halloween2025> postHalloween2025WithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        okhttp3.Call localVarCall = postHalloween2025ValidateBeforeCall(date, postQueryBody, null);
        Type localVarReturnType = new TypeToken<Halloween2025>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Halloween 2025 (asynchronously)
     * Permet d&#39;obtenir les statistiques des joueurs du top 50 de l&#39;événement Halloween 2025 \&quot;Demon&#39;s Return\&quot; à une date donnée (avec filtrage possible). Seuls les joueurs du top 50 interserveur sont disponibles (limitation du serveur).  **À propos de l&#39;événement :** L&#39;événement \&quot;Demon&#39;s Return\&quot; est un événement global interserveur où l&#39;objectif est de collecter des âmes et tuer des démons pour empêcher l&#39;invasion démoniaque. Le classement est identique sur tous les serveurs puisqu&#39;il s&#39;agit d&#39;un événement global à NationsGlory.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 21/10/2025 au 04/11/2025), généralement la nuit.  **Documentation :** Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/halloween-2025-demons-return-1lfsu05/ 
     * @param date Date des données au format ISO-8601 (yyyy-MM-dd). Événement actif du 21/10/2025 au 13/11/2025, données actualisées quotidiennement (required)
     * @param postQueryBody  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postHalloween2025Async(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback<Halloween2025> _callback) throws ApiException {

        okhttp3.Call localVarCall = postHalloween2025ValidateBeforeCall(date, postQueryBody, _callback);
        Type localVarReturnType = new TypeToken<Halloween2025>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postNoelMegagift2024
     * @param postQueryBody  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postNoelMegagift2024Call(@javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postQueryBody;

        // create path and map variables
        String localVarPath = "/v2/java/noelmegagift-2024";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postNoelMegagift2024ValidateBeforeCall(@javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        return postNoelMegagift2024Call(postQueryBody, _callback);

    }

    /**
     * Noël Megagift 2024
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement \&quot;The Key Guardian\&quot; (Noël 2024).  **À propos de l&#39;événement :** L&#39;événement \&quot;The Key Guardian\&quot; est l&#39;événement de Noël 2024 où les joueurs doivent à récupérer 9 clés perdues pour assembler une Méga Clé et débloquer le Mega Cadeau. Chaque tirage du Mega Cadeau offre jusqu&#39;à 4 récompenses selon le nombre de joueurs présents (armes exclusives, plans rares, items légendaires, cosmétiques).  **Période de l&#39;événement :** Du 24/12/2024 au 12/01/2025  **Données exposées :** Chaque entrée représente un tirage individuel du Mega Gift par un joueur, avec les items obtenus et la date/heure du tirage. 
     * @param postQueryBody  (optional)
     * @return NoelMegagift2024
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public NoelMegagift2024 postNoelMegagift2024(@javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        ApiResponse<NoelMegagift2024> localVarResp = postNoelMegagift2024WithHttpInfo(postQueryBody);
        return localVarResp.getData();
    }

    /**
     * Noël Megagift 2024
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement \&quot;The Key Guardian\&quot; (Noël 2024).  **À propos de l&#39;événement :** L&#39;événement \&quot;The Key Guardian\&quot; est l&#39;événement de Noël 2024 où les joueurs doivent à récupérer 9 clés perdues pour assembler une Méga Clé et débloquer le Mega Cadeau. Chaque tirage du Mega Cadeau offre jusqu&#39;à 4 récompenses selon le nombre de joueurs présents (armes exclusives, plans rares, items légendaires, cosmétiques).  **Période de l&#39;événement :** Du 24/12/2024 au 12/01/2025  **Données exposées :** Chaque entrée représente un tirage individuel du Mega Gift par un joueur, avec les items obtenus et la date/heure du tirage. 
     * @param postQueryBody  (optional)
     * @return ApiResponse&lt;NoelMegagift2024&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NoelMegagift2024> postNoelMegagift2024WithHttpInfo(@javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        okhttp3.Call localVarCall = postNoelMegagift2024ValidateBeforeCall(postQueryBody, null);
        Type localVarReturnType = new TypeToken<NoelMegagift2024>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Noël Megagift 2024 (asynchronously)
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement \&quot;The Key Guardian\&quot; (Noël 2024).  **À propos de l&#39;événement :** L&#39;événement \&quot;The Key Guardian\&quot; est l&#39;événement de Noël 2024 où les joueurs doivent à récupérer 9 clés perdues pour assembler une Méga Clé et débloquer le Mega Cadeau. Chaque tirage du Mega Cadeau offre jusqu&#39;à 4 récompenses selon le nombre de joueurs présents (armes exclusives, plans rares, items légendaires, cosmétiques).  **Période de l&#39;événement :** Du 24/12/2024 au 12/01/2025  **Données exposées :** Chaque entrée représente un tirage individuel du Mega Gift par un joueur, avec les items obtenus et la date/heure du tirage. 
     * @param postQueryBody  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postNoelMegagift2024Async(@javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback<NoelMegagift2024> _callback) throws ApiException {

        okhttp3.Call localVarCall = postNoelMegagift2024ValidateBeforeCall(postQueryBody, _callback);
        Type localVarReturnType = new TypeToken<NoelMegagift2024>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postNoelMegagift2025
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @param postQueryBody  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postNoelMegagift2025Call(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postQueryBody;

        // create path and map variables
        String localVarPath = "/v2/java/noelmegagift-2025/{date}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postNoelMegagift2025ValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling postNoelMegagift2025(Async)");
        }

        return postNoelMegagift2025Call(date, postQueryBody, _callback);

    }

    /**
     * Noël Megagift 2025
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement de Noël 2025 (filtrage RSQL possible).  **À propos de l&#39;événement :** Événement interserveur où les joueurs peuvent obtenir des récompenses exclusives via le Mega Cadeau. Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/lile-du-pere-noel-rv8x0t/#2-le-mega-cadeau-recompense-ultime  **Période de l&#39;événement :** Du 14/12/2025 au 06/01/2026  **Données exposées :** Chaque entrée représente un tirage individuel du Mega cadeau par un joueur, avec les items obtenus et la date/heure du tirage.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 14/12/2025 au 06/01/2026), généralement la nuit. 
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @param postQueryBody  (optional)
     * @return NoelMegagift2025
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public NoelMegagift2025 postNoelMegagift2025(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        ApiResponse<NoelMegagift2025> localVarResp = postNoelMegagift2025WithHttpInfo(date, postQueryBody);
        return localVarResp.getData();
    }

    /**
     * Noël Megagift 2025
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement de Noël 2025 (filtrage RSQL possible).  **À propos de l&#39;événement :** Événement interserveur où les joueurs peuvent obtenir des récompenses exclusives via le Mega Cadeau. Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/lile-du-pere-noel-rv8x0t/#2-le-mega-cadeau-recompense-ultime  **Période de l&#39;événement :** Du 14/12/2025 au 06/01/2026  **Données exposées :** Chaque entrée représente un tirage individuel du Mega cadeau par un joueur, avec les items obtenus et la date/heure du tirage.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 14/12/2025 au 06/01/2026), généralement la nuit. 
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @param postQueryBody  (optional)
     * @return ApiResponse&lt;NoelMegagift2025&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<NoelMegagift2025> postNoelMegagift2025WithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        okhttp3.Call localVarCall = postNoelMegagift2025ValidateBeforeCall(date, postQueryBody, null);
        Type localVarReturnType = new TypeToken<NoelMegagift2025>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Noël Megagift 2025 (asynchronously)
     * Permet d&#39;obtenir les données des tirages du Mega Cadeau de l&#39;événement de Noël 2025 (filtrage RSQL possible).  **À propos de l&#39;événement :** Événement interserveur où les joueurs peuvent obtenir des récompenses exclusives via le Mega Cadeau. Plus d&#39;informations sur l&#39;événement : https://wiki.nationsglory.fr/fr/article/lile-du-pere-noel-rv8x0t/#2-le-mega-cadeau-recompense-ultime  **Période de l&#39;événement :** Du 14/12/2025 au 06/01/2026  **Données exposées :** Chaque entrée représente un tirage individuel du Mega cadeau par un joueur, avec les items obtenus et la date/heure du tirage.  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement pendant toute la durée de l&#39;événement (du 14/12/2025 au 06/01/2026), généralement la nuit. 
     * @param date Date de la configuration (format ISO-8601: yyyy-MM-dd) (required)
     * @param postQueryBody  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postNoelMegagift2025Async(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback<NoelMegagift2025> _callback) throws ApiException {

        okhttp3.Call localVarCall = postNoelMegagift2025ValidateBeforeCall(date, postQueryBody, _callback);
        Type localVarReturnType = new TypeToken<NoelMegagift2025>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postPlayerList
     * @param date La date à laquelle on veut récupérer la liste des joueurs (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut la liste des joueurs. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postPlayerListCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postQueryBody;

        // create path and map variables
        String localVarPath = "/v2/java/player-list/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postPlayerListValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling postPlayerList(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling postPlayerList(Async)");
        }

        return postPlayerListCall(date, javaServer, postQueryBody, _callback);

    }

    /**
     * Player List
     * Permet d&#39;obtenir la liste des joueurs s&#39;étant connectés au moins une fois au cours des 14 derniers jours sur un serveur à une date donnée (avec filtrage possible).  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date La date à laquelle on veut récupérer la liste des joueurs (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut la liste des joueurs. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return PlayerList
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public PlayerList postPlayerList(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        ApiResponse<PlayerList> localVarResp = postPlayerListWithHttpInfo(date, javaServer, postQueryBody);
        return localVarResp.getData();
    }

    /**
     * Player List
     * Permet d&#39;obtenir la liste des joueurs s&#39;étant connectés au moins une fois au cours des 14 derniers jours sur un serveur à une date donnée (avec filtrage possible).  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date La date à laquelle on veut récupérer la liste des joueurs (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut la liste des joueurs. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return ApiResponse&lt;PlayerList&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PlayerList> postPlayerListWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        okhttp3.Call localVarCall = postPlayerListValidateBeforeCall(date, javaServer, postQueryBody, null);
        Type localVarReturnType = new TypeToken<PlayerList>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Player List (asynchronously)
     * Permet d&#39;obtenir la liste des joueurs s&#39;étant connectés au moins une fois au cours des 14 derniers jours sur un serveur à une date donnée (avec filtrage possible).  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date La date à laquelle on veut récupérer la liste des joueurs (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut la liste des joueurs. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postPlayerListAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback<PlayerList> _callback) throws ApiException {

        okhttp3.Call localVarCall = postPlayerListValidateBeforeCall(date, javaServer, postQueryBody, _callback);
        Type localVarReturnType = new TypeToken<PlayerList>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postResearchServer
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de R&amp;D. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postResearchServerCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postQueryBody;

        // create path and map variables
        String localVarPath = "/v2/java/research/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postResearchServerValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling postResearchServer(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling postResearchServer(Async)");
        }

        return postResearchServerCall(date, javaServer, postQueryBody, _callback);

    }

    /**
     * Research Server
     * Permet d&#39;obtenir les niveaux de recherche actuels de tous les pays d&#39;un serveur à une date donnée (avec filtrage possible).  **Données exposées :** - Niveaux actuels de recherche par domaine pour chaque pays - Dernière recherche complétée par chaque pays - Valeurs actuelles des conditions de recherche  **Exemples de filtres RSQL :** - &#x60;country&#x3D;&#x3D;Papouasie&#x60; - Pays nommé exactement \&quot;Papouasie\&quot; - &#x60;country&#x3D;&#x3D;*Terre*&#x60; - Pays dont le nom contient \&quot;Terre\&quot; - &#x60;lastResearch.level&gt;3&#x60; - Pays dont la dernière recherche a atteint un niveau &gt; 3 - &#x60;lastResearch.domain&#x3D;&#x3D;militaire&#x60; - Pays dont la dernière recherche était dans le domaine militaire - &#x60;lastResearch.timestamp&gt;1735689600000&#x60; - Pays dont la dernière recherche a été complétée après cette date  **Fréquence de mise à jour :** Les données sont actualisées tous les jours pairs du mois (environ une fois tous les 2 jours), généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de R&amp;D. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return ResearchServer
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ResearchServer postResearchServer(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        ApiResponse<ResearchServer> localVarResp = postResearchServerWithHttpInfo(date, javaServer, postQueryBody);
        return localVarResp.getData();
    }

    /**
     * Research Server
     * Permet d&#39;obtenir les niveaux de recherche actuels de tous les pays d&#39;un serveur à une date donnée (avec filtrage possible).  **Données exposées :** - Niveaux actuels de recherche par domaine pour chaque pays - Dernière recherche complétée par chaque pays - Valeurs actuelles des conditions de recherche  **Exemples de filtres RSQL :** - &#x60;country&#x3D;&#x3D;Papouasie&#x60; - Pays nommé exactement \&quot;Papouasie\&quot; - &#x60;country&#x3D;&#x3D;*Terre*&#x60; - Pays dont le nom contient \&quot;Terre\&quot; - &#x60;lastResearch.level&gt;3&#x60; - Pays dont la dernière recherche a atteint un niveau &gt; 3 - &#x60;lastResearch.domain&#x3D;&#x3D;militaire&#x60; - Pays dont la dernière recherche était dans le domaine militaire - &#x60;lastResearch.timestamp&gt;1735689600000&#x60; - Pays dont la dernière recherche a été complétée après cette date  **Fréquence de mise à jour :** Les données sont actualisées tous les jours pairs du mois (environ une fois tous les 2 jours), généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de R&amp;D. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return ApiResponse&lt;ResearchServer&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ResearchServer> postResearchServerWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        okhttp3.Call localVarCall = postResearchServerValidateBeforeCall(date, javaServer, postQueryBody, null);
        Type localVarReturnType = new TypeToken<ResearchServer>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Research Server (asynchronously)
     * Permet d&#39;obtenir les niveaux de recherche actuels de tous les pays d&#39;un serveur à une date donnée (avec filtrage possible).  **Données exposées :** - Niveaux actuels de recherche par domaine pour chaque pays - Dernière recherche complétée par chaque pays - Valeurs actuelles des conditions de recherche  **Exemples de filtres RSQL :** - &#x60;country&#x3D;&#x3D;Papouasie&#x60; - Pays nommé exactement \&quot;Papouasie\&quot; - &#x60;country&#x3D;&#x3D;*Terre*&#x60; - Pays dont le nom contient \&quot;Terre\&quot; - &#x60;lastResearch.level&gt;3&#x60; - Pays dont la dernière recherche a atteint un niveau &gt; 3 - &#x60;lastResearch.domain&#x3D;&#x3D;militaire&#x60; - Pays dont la dernière recherche était dans le domaine militaire - &#x60;lastResearch.timestamp&gt;1735689600000&#x60; - Pays dont la dernière recherche a été complétée après cette date  **Fréquence de mise à jour :** Les données sont actualisées tous les jours pairs du mois (environ une fois tous les 2 jours), généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de R&amp;D. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postResearchServerAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback<ResearchServer> _callback) throws ApiException {

        okhttp3.Call localVarCall = postResearchServerValidateBeforeCall(date, javaServer, postQueryBody, _callback);
        Type localVarReturnType = new TypeToken<ResearchServer>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postSkill
     * @param date La date à laquelle on veut récupéré les skills (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les skills. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSkillCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postQueryBody;

        // create path and map variables
        String localVarPath = "/v2/java/skill/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postSkillValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling postSkill(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling postSkill(Async)");
        }

        return postSkillCall(date, javaServer, postQueryBody, _callback);

    }

    /**
     * Skill
     * Permet d&#39;obtenir les compétences des joueurs présents dans au moins 1 top 50 compétences sur un serveur à une date donnée (avec filtrage possible). Seuls les joueurs figurant dans le top 50 d&#39;au moins une compétence sur le serveur sont inclus pour éviter de surcharger les serveurs.  **Fréquence de mise à jour :** Les données sont actualisées tous les jours pairs du mois (environ une fois tous les 2 jours), généralement la nuit.  **Documentation :** Plus d&#39;informations sur les compétences/skills : https://wiki.nationsglory.fr/fr/article/les-competences-java-1shixp7/ 
     * @param date La date à laquelle on veut récupéré les skills (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les skills. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return Skill
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Skill postSkill(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        ApiResponse<Skill> localVarResp = postSkillWithHttpInfo(date, javaServer, postQueryBody);
        return localVarResp.getData();
    }

    /**
     * Skill
     * Permet d&#39;obtenir les compétences des joueurs présents dans au moins 1 top 50 compétences sur un serveur à une date donnée (avec filtrage possible). Seuls les joueurs figurant dans le top 50 d&#39;au moins une compétence sur le serveur sont inclus pour éviter de surcharger les serveurs.  **Fréquence de mise à jour :** Les données sont actualisées tous les jours pairs du mois (environ une fois tous les 2 jours), généralement la nuit.  **Documentation :** Plus d&#39;informations sur les compétences/skills : https://wiki.nationsglory.fr/fr/article/les-competences-java-1shixp7/ 
     * @param date La date à laquelle on veut récupéré les skills (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les skills. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return ApiResponse&lt;Skill&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Skill> postSkillWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        okhttp3.Call localVarCall = postSkillValidateBeforeCall(date, javaServer, postQueryBody, null);
        Type localVarReturnType = new TypeToken<Skill>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Skill (asynchronously)
     * Permet d&#39;obtenir les compétences des joueurs présents dans au moins 1 top 50 compétences sur un serveur à une date donnée (avec filtrage possible). Seuls les joueurs figurant dans le top 50 d&#39;au moins une compétence sur le serveur sont inclus pour éviter de surcharger les serveurs.  **Fréquence de mise à jour :** Les données sont actualisées tous les jours pairs du mois (environ une fois tous les 2 jours), généralement la nuit.  **Documentation :** Plus d&#39;informations sur les compétences/skills : https://wiki.nationsglory.fr/fr/article/les-competences-java-1shixp7/ 
     * @param date La date à laquelle on veut récupéré les skills (au format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les skills. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postSkillAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback<Skill> _callback) throws ApiException {

        okhttp3.Call localVarCall = postSkillValidateBeforeCall(date, javaServer, postQueryBody, _callback);
        Type localVarReturnType = new TypeToken<Skill>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for postWar
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postWarCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = postQueryBody;

        // create path and map variables
        String localVarPath = "/v2/java/war/{date}/{javaServer}"
            .replace("{" + "date" + "}", localVarApiClient.escapeString(date.toString()))
            .replace("{" + "javaServer" + "}", localVarApiClient.escapeString(javaServer.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "oauth2_client_credentials" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call postWarValidateBeforeCall(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'date' is set
        if (date == null) {
            throw new ApiException("Missing the required parameter 'date' when calling postWar(Async)");
        }

        // verify the required parameter 'javaServer' is set
        if (javaServer == null) {
            throw new ApiException("Missing the required parameter 'javaServer' when calling postWar(Async)");
        }

        return postWarCall(date, javaServer, postQueryBody, _callback);

    }

    /**
     * War
     * Permet d&#39;obtenir la liste des guerres (en cours ou terminées) d&#39;un serveur à une date donnée (avec filtrage possible).  **Données exposées :** - Identifiant, dates (déclaration, début), raison - Participants (attaquant, défenseur) avec détails (pays, points missiles, progression...) - Conditions de victoire - Récompenses - Détails des assauts et missiles lancés  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return War
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public War postWar(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        ApiResponse<War> localVarResp = postWarWithHttpInfo(date, javaServer, postQueryBody);
        return localVarResp.getData();
    }

    /**
     * War
     * Permet d&#39;obtenir la liste des guerres (en cours ou terminées) d&#39;un serveur à une date donnée (avec filtrage possible).  **Données exposées :** - Identifiant, dates (déclaration, début), raison - Participants (attaquant, défenseur) avec détails (pays, points missiles, progression...) - Conditions de victoire - Récompenses - Détails des assauts et missiles lancés  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @return ApiResponse&lt;War&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<War> postWarWithHttpInfo(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody) throws ApiException {
        okhttp3.Call localVarCall = postWarValidateBeforeCall(date, javaServer, postQueryBody, null);
        Type localVarReturnType = new TypeToken<War>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * War (asynchronously)
     * Permet d&#39;obtenir la liste des guerres (en cours ou terminées) d&#39;un serveur à une date donnée (avec filtrage possible).  **Données exposées :** - Identifiant, dates (déclaration, début), raison - Participants (attaquant, défenseur) avec détails (pays, points missiles, progression...) - Conditions de victoire - Récompenses - Détails des assauts et missiles lancés  **Fréquence de mise à jour :** Les données sont actualisées quotidiennement, généralement la nuit. 
     * @param date Date des données (format ISO-8601: yyyy-MM-dd). Si aucune donnée n&#39;a été scrap ce jour là, la date antérieure la plus proche sera utilisée (required)
     * @param javaServer Serveur NationsGlory dont on veut les données de guerre. Valeurs possibles : blue, orange, yellow, white, black, cyan, lime, coral, pink, purple, green, red, mocha et jade (required)
     * @param postQueryBody  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call postWarAsync(@javax.annotation.Nonnull LocalDate date, @javax.annotation.Nonnull String javaServer, @javax.annotation.Nullable PostQueryBody postQueryBody, final ApiCallback<War> _callback) throws ApiException {

        okhttp3.Call localVarCall = postWarValidateBeforeCall(date, javaServer, postQueryBody, _callback);
        Type localVarReturnType = new TypeToken<War>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
