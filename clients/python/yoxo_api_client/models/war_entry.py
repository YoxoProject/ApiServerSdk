# coding: utf-8

"""
    Yoxo API Server

    API REST exposant diverses données liées aux serveurs de NationsGlory.  ## À propos Cette API centralise et expose différents types de données relatives aux serveurs de NationsGlory : - **Routes `/v2/java/*`** : Données collectées par scraping direct sur les serveurs Java de NationsGlory. Pour cela, le protocole 78 (Minecraft 1.6.4) est pleinement utilisé. - **Autres routes** (à venir) : Données obtenues par d'autres méthodes (API officielles, DynMap, etc.)  ## Authentification L'API utilise le flux OAuth2 Client Credentials. Pour vous authentifier : 1. Obtenez vos identifiants client (client_id et client_secret) depuis le serveur d'authentification de Yoxo 2. Demandez un jeton d'accès : `POST https://auth.yoxo.software/oauth2/token`    ```    grant_type=client_credentials    &client_id=votre_client_id    &client_secret=votre_client_secret    &scope=api_access    ``` 3. Incluez le jeton dans l'en-tête Authorization : `Bearer <token>`  ## Filtrage RSQL Utilisez le paramètre de requête `filter` avec la syntaxe RSQL : - **Opérateurs** : `==`, `!=`, `>`, `>=`, `<`, `<=` - **Logique** : `;` (ET), `,` (OU), `()` pour grouper - **Wildcards** : `*` pour contains/startsWith/endsWith - **Exemples** :   - `b>100000` : niveau global > 100000   - `u==*Romain*` : nom d'utilisateur contenant \"Romain\"   - `b>500000;bP<100` : niveau > 500000 ET position < 100   - `(u==*35*,u==*76*)` : nom contenant \"35\" OU \"76\" 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from yoxo_api_client.models.war_assault import WarAssault
from yoxo_api_client.models.war_condition import WarCondition
from yoxo_api_client.models.war_missile import WarMissile
from yoxo_api_client.models.war_participant import WarParticipant
from yoxo_api_client.models.war_rewards import WarRewards
from typing import Optional, Set
from typing_extensions import Self

class WarEntry(BaseModel):
    """
    Détails d'une guerre
    """ # noqa: E501
    war_id: Optional[StrictStr] = Field(default=None, description="Identifiant unique de la guerre permettant de lier avec les données des pays", alias="warId")
    war_declared_at: Optional[StrictInt] = Field(default=None, description="Timestamp (ms) de la déclaration de guerre", alias="warDeclaredAt")
    war_start_at: Optional[StrictInt] = Field(default=None, description="Timestamp (ms) du début effectif de la guerre", alias="warStartAt")
    wars_initiated_by: Optional[StrictStr] = Field(default=None, description="Joueur ayant initié la guerre via la commande /f enemy", alias="warsInitiatedBy")
    reason: Optional[StrictStr] = Field(default=None, description="Raison de la déclaration de guerre")
    target: Optional[StrictStr] = Field(default=None, description="Le pays ou joueur ayant donné la raison de guerre (peut être nul selon la raison)")
    target_grade: Optional[StrictStr] = Field(default=None, description="Grade du joueur ayant donné la raison de guerre (au moment de la raison de la guerre)", alias="targetGrade")
    status: Optional[StrictStr] = Field(default=None, description="Statut actuel de la guerre (ex: IN_PROGRESS, FINISHED)")
    winner: Optional[StrictStr] = Field(default=None, description="Le nom du pays vainqueur de la guerre (si terminée)")
    days_before_missile_point_reset: Optional[StrictInt] = Field(default=None, description="Nombre de jours restants avant la réinitialisation des points missile", alias="daysBeforeMissilePointReset")
    attacker: Optional[WarParticipant] = None
    defender: Optional[WarParticipant] = None
    conditions: Optional[WarCondition] = None
    condition_type: Optional[StrictStr] = Field(default=None, description="Logique d'application des conditions (AND: toutes requises, OR: une seule requise)", alias="conditionType")
    rewards: Optional[WarRewards] = None
    assaults: Optional[List[WarAssault]] = Field(default=None, description="Liste des assauts ayant eu lieu durant la guerre")
    missiles: Optional[List[WarMissile]] = Field(default=None, description="Liste des missiles lancés durant la guerre")
    __properties: ClassVar[List[str]] = ["warId", "warDeclaredAt", "warStartAt", "warsInitiatedBy", "reason", "target", "targetGrade", "status", "winner", "daysBeforeMissilePointReset", "attacker", "defender", "conditions", "conditionType", "rewards", "assaults", "missiles"]

    @field_validator('reason')
    def reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['KILL_WILDERNESS', 'PROVOCATION', 'TERRITORIAL_EXPANSION', 'TREASON', 'INTRUSION', 'SCAM', 'TPKILL', 'COLONY_IMDEPENDENCE', 'COLONY_REFUSAL', 'COLONY_PROTECTION', 'COLONY_STEAL', 'BUFFER_COUNTRY', 'UNDER_POWER', 'REPRISAL', 'FOLLOW_WAR', 'MMR500', 'EMPIRE_RIVALITY', 'WAR_REVENGE', 'BOMBING_ASSISTANCE', 'WARZONE_DOMINATION', 'PROTECTORAT']):
            raise ValueError("must be one of enum values ('KILL_WILDERNESS', 'PROVOCATION', 'TERRITORIAL_EXPANSION', 'TREASON', 'INTRUSION', 'SCAM', 'TPKILL', 'COLONY_IMDEPENDENCE', 'COLONY_REFUSAL', 'COLONY_PROTECTION', 'COLONY_STEAL', 'BUFFER_COUNTRY', 'UNDER_POWER', 'REPRISAL', 'FOLLOW_WAR', 'MMR500', 'EMPIRE_RIVALITY', 'WAR_REVENGE', 'BOMBING_ASSISTANCE', 'WARZONE_DOMINATION', 'PROTECTORAT')")
        return value

    @field_validator('target_grade')
    def target_grade_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['RECRUIT', 'MEMBER', 'OFFICER', 'LEADER']):
            raise ValueError("must be one of enum values ('RECRUIT', 'MEMBER', 'OFFICER', 'LEADER')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['IN_PROGRESS', 'WAITING_VALIDATION', 'WAITING_CONDITIONS_ATT', 'WAITING_CONDITIONS_DEF', 'WAITING_CONDITIONS_ATT_VALIDATION', 'FINISHED', 'REFUSED']):
            raise ValueError("must be one of enum values ('IN_PROGRESS', 'WAITING_VALIDATION', 'WAITING_CONDITIONS_ATT', 'WAITING_CONDITIONS_DEF', 'WAITING_CONDITIONS_ATT_VALIDATION', 'FINISHED', 'REFUSED')")
        return value

    @field_validator('condition_type')
    def condition_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['OR', 'AND']):
            raise ValueError("must be one of enum values ('OR', 'AND')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of WarEntry from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of attacker
        if self.attacker:
            _dict['attacker'] = self.attacker.to_dict()
        # override the default output from pydantic by calling `to_dict()` of defender
        if self.defender:
            _dict['defender'] = self.defender.to_dict()
        # override the default output from pydantic by calling `to_dict()` of conditions
        if self.conditions:
            _dict['conditions'] = self.conditions.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rewards
        if self.rewards:
            _dict['rewards'] = self.rewards.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in assaults (list)
        _items = []
        if self.assaults:
            for _item_assaults in self.assaults:
                if _item_assaults:
                    _items.append(_item_assaults.to_dict())
            _dict['assaults'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in missiles (list)
        _items = []
        if self.missiles:
            for _item_missiles in self.missiles:
                if _item_missiles:
                    _items.append(_item_missiles.to_dict())
            _dict['missiles'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of WarEntry from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "warId": obj.get("warId"),
            "warDeclaredAt": obj.get("warDeclaredAt"),
            "warStartAt": obj.get("warStartAt"),
            "warsInitiatedBy": obj.get("warsInitiatedBy"),
            "reason": obj.get("reason"),
            "target": obj.get("target"),
            "targetGrade": obj.get("targetGrade"),
            "status": obj.get("status"),
            "winner": obj.get("winner"),
            "daysBeforeMissilePointReset": obj.get("daysBeforeMissilePointReset"),
            "attacker": WarParticipant.from_dict(obj["attacker"]) if obj.get("attacker") is not None else None,
            "defender": WarParticipant.from_dict(obj["defender"]) if obj.get("defender") is not None else None,
            "conditions": WarCondition.from_dict(obj["conditions"]) if obj.get("conditions") is not None else None,
            "conditionType": obj.get("conditionType"),
            "rewards": WarRewards.from_dict(obj["rewards"]) if obj.get("rewards") is not None else None,
            "assaults": [WarAssault.from_dict(_item) for _item in obj["assaults"]] if obj.get("assaults") is not None else None,
            "missiles": [WarMissile.from_dict(_item) for _item in obj["missiles"]] if obj.get("missiles") is not None else None
        })
        return _obj


